using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using System.Text;
using UnityEditor;


public class TransformInfo
{
    public Vector3 position;
    public Quaternion rotation;
}
public class LSystemTree : MonoBehaviour
{
    public bool randomIgnoreRuleModifier = true;
    public float chanceToIgnoreRule = 0.3f;
    
    [SerializeField] private bool randomizeIterations = false;
    [SerializeField] private bool randomizeHeight = false;
    [Range(2, 4)][SerializeField] private int iterationLimit = 2;
    [SerializeField] private GameObject Branch;
    [SerializeField] private GameObject Leaf;
    private float lengthBranch = 10f; //keep it private so the user can randomize height by just clicking the bool randomizeHeight, without manually changing the height variable
    //[SerializeField] private float lengthLeaf = 10f;
    [SerializeField] private float angle = 20f;
    //private const float WidthBranches = 8f;
    private float TrunkWidth = 7f;  //I want to keep this private because the aim of the project it's creating multiple trees in random form,
                                    //so I don't want that an user changes the width of the trunk for making a single tree beatiful, I want it to be
                                    //always the one that I designed so it will look good with all types of iterations and so will be considered "ok" for all types of possible random trees
    private Stack<TransformInfo> transformStack;
    //private Dictionary<char, string> rules;
    private LSystemGenerator lsystem;
    public LSRule[] rules;
    [SerializeField] public string axiom = "X";
    //public float variance = 10f;
    //private string currentString = string.Empty;


   /* void Start()
    {
        transformStack = new Stack<TransformInfo>();

        rules = new Dictionary<char, string>
        {
            {'X',"[F[-X+F[+FX]][*-X+F[+FX]][/-X+F[+FX]-X]]"}, ALL F will become leaves, except for the first one that will represent the stem of the tree,
            {'X',"[F[-X+F[+LX]][*-X+F[+LX]][/-X+F[+LX]-X]]"}
            {'F',"FF"}
            parte con X perchè è la X dell'assioma, le lettere non vengono eliminate, però producono regole e poi non vengono più cagate alle iterazioni dopo?
            La risposta è sì perchè è un processo ricorsivo. producono la regola però rimangono, es F produce FF e all'iterazione dopo avrò FFF, perchè la prima F non viene consumata ma rimane
            tuttavia all'iterazione dopo ancora quella prima F non produce più la regola perchè è già stata consumata ed essendo un procedimento ricorsivo si riesce a tenere traccai di questo meccanismo
            axiom: X
            it1: X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]
            it2: X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]+FFF[+L][[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]]++X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]]*++X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]]]
        };
        Generate();
    }*/
    
     private void Start()
    {
        
        transformStack = new Stack<TransformInfo>();
        // the only test we perform on the validity of the L-system is to have the axiom not null.
        if(randomizeIterations){
            iterationLimit =  UnityEngine.Random.Range(2, 5); // 2, 3, 4 are the possible iterations
        }
        if(randomizeHeight){
            lengthBranch = UnityEngine.Random.Range(6f, 11f); //from 6 to 10
        }
        if (axiom != string.Empty)
        {
            lsystem = new LSystemGenerator(rules, iterationLimit, randomIgnoreRuleModifier, chanceToIgnoreRule);
            // we generate the sentence given axiom and rule
            var sequence = lsystem.GenerateSentence(axiom);
            Debug.Log(sequence);
            // we parse the final sentence
            ParseAndBuild(sequence); //graphic result based on the sequence generated by the grammar
            //NOT IN USE
            //AdjustCircleOfNoTrees(iterationLimit);//last thing adjust the circonference where Trees can't spawn nearby
        }
        else
        {
        //CAPIRE STA PARTEEEEEEEEEE
        //
        //
        //
#           if UNITY_EDITOR
            EditorUtility.DisplayDialog("Axiom is empty!", "", "Ok");
            if (EditorApplication.isPlaying)
                UnityEditor.EditorApplication.isPlaying = false;
            #endif
        }
    }
    //NOT IN USE
    //Trees can't spawn nearby, it's adjusted with the size of the tree, if ANYONE doesn't want this feature, he just can scale the size of the component "NoTreesInside" to 0 .
    /*private void AdjustCircleOfNoTrees(int iterationLimit){
        //need to add exception handling
        Transform NoTreesHere = this.transform.GetChild(0);
        Vector3 NoTreesScale = NoTreesHere.localScale;
        NoTreesHere.localScale = new Vector3((float)Math.Pow(NoTreesScale.x, iterationLimit), (float)Math.Pow(NoTreesScale.y, iterationLimit), (float)Math.Pow(NoTreesScale.z, iterationLimit));
    }*/
    private void ParseAndBuild(String sequence){
        int i = 0;
        //Basically a counter for the [, unitil the second [, I assume that the branches are trunk.
        //It's not the best since if I have a different structure of the tree it might produce not so beatiful results
        //it is also good to say that usualy u dont pop until the trunk as been created, so basically 99% of time the first [ it's always trunk
        //with the second one the problems might start for different structures of L-Systems.
        //Even if it's not the best for modularity I couldn't find a better solution, I tried to put a rule T-->TT and the axiom to become TX so 
        //I  had the trunk before the actually tree, but the problem is that removing the first F didn't just remove the first part of the trunk but it also
        //make the tree more compact and make it look really bad, so I decided to keep this not so modular implementation that works good with my grammars.
        int countForTrunk = 2; 
        //will be usefull at the end
        List<GameObject> TreeComponents = new List<GameObject>();
        foreach(char c in sequence){
            switch(c)
            {   
                //NO INTERNAL LEAVES 4:
                //X[FFFFFFFFFFFFFFF[-X[FFFFFFF[-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][*-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][/-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]]]+FFFFFFFFFFFFFFF[+L]][*-X[FFFFFFF[-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][*-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][/-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]]]+FFFFFFFFFFFFFFF[+L]][/-X[FFFFFFF[-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][*-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][/-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]]]+FFFFFFFFFFFFFFF[+L]-X[FFFFFFF[-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][*-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][/-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]]]]]
                //PERFECT RULE:[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]

                //devo far scalare il cerchio in base alla grandezza dell'albero.
                case 'F':
                    Vector3 initialPosision = transform.position;
                    transform.Translate(Vector3.up * lengthBranch); //Moves the transform in the direction and distance of translation.

                    GameObject treeSegment = Instantiate(Branch, transform);
                    treeSegment.GetComponent<LineRenderer>().SetPosition(0,initialPosision); 
                    treeSegment.GetComponent<LineRenderer>().SetPosition(1,transform.position);
                    treeSegment.GetComponent<LineRenderer>().startWidth = TrunkWidth;
                    treeSegment.GetComponent<LineRenderer>().endWidth = TrunkWidth;
                    TreeComponents.Add(treeSegment);
                    break;
                case 'L':  
                    Vector3 IP = new Vector3(transform.position.x, transform.position.y-4, transform.position.z); // sposto di 2 in su le y.
                    GameObject l = Instantiate(Leaf);
                    l.transform.position = IP;
                    TreeComponents.Add(l);
                    break;
                    //X = basic structure of the tree
                case 'X':
                    break;
                    //clockwise on z axis
               case '+':
                    transform.Rotate(Vector3.back *  (angle  + UnityEngine.Random.Range(2f, 5f))); //add randomity to angles
                    break;
                    //reverse clockwise on z axis
                case '-':                                      
                    transform.Rotate(Vector3.forward * (angle  + UnityEngine.Random.Range(2f, 5f)));
                    break;
                    //moving clockwise on y axis
                case '*':
                    transform.Rotate(Vector3.up * (120  + UnityEngine.Random.Range(5f, 10f)));
                    break;
                    //moving reverse clockwise on y axis
                case '/':
                    transform.Rotate(Vector3.down* (120  + UnityEngine.Random.Range(5f, 10f))); 
                    break;
                    //save turtle position
                case '[':
                    //The bigger the tree(iteration limit) the bigger the width of the branches.
                    if(countForTrunk <= 0){TrunkWidth = 2f + iterationLimit/2;}else{TrunkWidth = TrunkWidth + iterationLimit/2;}//if the trunk is ended i recompute the width to the width of the branches
                    //this solution is hardcoded to keep it "cool" with all possible random trees that my script can generate.
                    countForTrunk--;

                    transformStack.Push(new TransformInfo(){
                    position = transform.position,
                    rotation = transform.rotation
                });
                    break;
                    //turn back to saved position
                case ']':
                    TransformInfo ti = transformStack.Pop();
                    transform.position = ti.position;
                    transform.rotation = ti.rotation;
                    break;
                default:
                    throw new InvalidOperationException("invalid Tree operation");
            }
            i++;
        }
        //Keep the unity management of objects nice and clean
        //REMINDER FOR MYSELF: if I add them to the parent at each iteration, then the leaves' position will be buggy so I need to add them later
        foreach(GameObject g in TreeComponents){
            g.transform.SetParent(transform);
        }
    }
}
