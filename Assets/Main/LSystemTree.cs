using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using System.Text;
using UnityEditor;


public class TransformInfo
{
    public Vector3 position;
    public Quaternion rotation;
}
//DA DOCUMENTARE ASSOLUTAMENTE
public class LSystemTree : MonoBehaviour
{
    public bool randomIgnoreRuleModifier = true;
    public float chanceToIgnoreRule = 0.3f;
    [Range(2, 4)]
    public int iterationLimit = 1;
    [SerializeField] private GameObject Branch;
    [SerializeField] private GameObject Leaf;
    [SerializeField] private float lengthBranch = 10f;
    //[SerializeField] private float lengthLeaf = 10f;
    [SerializeField] private float angle = 20f;
    //private const float WidthBranches = 8f;
    public float TrunkWidth = 7f; // I use this width for branches too, but for the user of this script this change will affect only the width of the trunk.
                                // the width of the branches is based on the width of the iterations.
    private Stack<TransformInfo> transformStack;
    //private Dictionary<char, string> rules;
    private LSystemGenerator lsystem;
    public LSRule[] rules;
    [SerializeField] public string axiom = "X";
    //public float variance = 10f;
    //private string currentString = string.Empty;


   /* void Start()
    {
        transformStack = new Stack<TransformInfo>();

        rules = new Dictionary<char, string>
        {
            {'X',"[F[-X+F[+FX]][*-X+F[+FX]][/-X+F[+FX]-X]]"}, ALL F will become leaves, except for the first one that will represent the stem of the tree,
            {'X',"[F[-X+F[+LX]][*-X+F[+LX]][/-X+F[+LX]-X]]"}
            {'F',"FF"}
            parte con X perchè è la X dell'assioma, le lettere non vengono eliminate, però producono regole e poi non vengono più cagate alle iterazioni dopo?
            La risposta è sì perchè è un processo ricorsivo. producono la regola però rimangono, es F produce FF e all'iterazione dopo avrò FFF, perchè la prima F non viene consumata ma rimane
            tuttavia all'iterazione dopo ancora quella prima F non produce più la regola perchè è già stata consumata ed essendo un procedimento ricorsivo si riesce a tenere traccai di questo meccanismo
            axiom: X
            it1: X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]
            it2: X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]+FFF[+L][[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]]++X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]]*++X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L][[-X]++X]*++X]]]]
        };
        Generate();
    }*/
     private void Start()
    {
        transformStack = new Stack<TransformInfo>();
        // the only test we perform on the validity of the L-system is to have the axiom not null.
        if (axiom != string.Empty)
        {
            lsystem = new LSystemGenerator(rules, iterationLimit, randomIgnoreRuleModifier, chanceToIgnoreRule);
            // we generate the sentence given axiom and rule
            var sequence = lsystem.GenerateSentence(axiom);
            Debug.Log(sequence);
            // we parse the final sentence
            ParseAndBuild(sequence); //graphic result based on the sequence generated by the grammar
            //NOT IN USE
            //AdjustCircleOfNoTrees(iterationLimit);//last thing adjust the circonference where Trees can't spawn nearby
        }
        else
        {
        //CAPIRE STA PARTEEEEEEEEEE
        //
        //
        //
#           if UNITY_EDITOR
            EditorUtility.DisplayDialog("Axiom is empty!", "", "Ok");
            if (EditorApplication.isPlaying)
                UnityEditor.EditorApplication.isPlaying = false;
            #endif
        }
    }
    //NOT IN USE
    //Trees can't spawn nearby, it's adjusted with the size of the tree, if ANYONE doesn't want this feature, he just can scale the size of the component "NoTreesInside" to 0 .
    /*private void AdjustCircleOfNoTrees(int iterationLimit){
        //need to add exception handling
        Transform NoTreesHere = this.transform.GetChild(0);
        Vector3 NoTreesScale = NoTreesHere.localScale;
        NoTreesHere.localScale = new Vector3((float)Math.Pow(NoTreesScale.x, iterationLimit), (float)Math.Pow(NoTreesScale.y, iterationLimit), (float)Math.Pow(NoTreesScale.z, iterationLimit));
    }*/
    private void ParseAndBuild(String sequence){
        int i = 0;
        //Basically a counter for the [, unitil the second [, I assume that the branches are trunk.
        //It's not the best since if I have a different structure of the tree it might produce not so beatiful results
        //it is also good to say that usualy u dont pop until the trunk as been created, so basically 99% of time the first [ it's always trunk
        //with the second one the problems mught start for different structures of L-Systems.
        int countForTrunk = 2; 
        foreach(char c in sequence){
            switch(c)
            {   
                //NO INTERNAL LEAVES 4:
                //X[FFFFFFFFFFFFFFF[-X[FFFFFFF[-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][*-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][/-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]]]+FFFFFFFFFFFFFFF[+L]][*-X[FFFFFFF[-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][*-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][/-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]]]+FFFFFFFFFFFFFFF[+L]][/-X[FFFFFFF[-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][*-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][/-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]]]+FFFFFFFFFFFFFFF[+L]-X[FFFFFFF[-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][*-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]][/-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]+FFFFFFF[+L]-X[FFF[-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][*-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]][/-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]+FFF[+L]-X[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]]]]]]]
                //PERFECT RULE:[F[-X+F[+L]][*-X+F[+L]][/-X+F[+L]-X]]


                //devo far scalare il cerchio in base alla grandezza dell'albero.
                case 'F':
                    Vector3 initialPosision = transform.position;
                    transform.Translate(Vector3.up * lengthBranch); //Moves the transform in the direction and distance of translation.

                    GameObject treeSegment = Instantiate(Branch);
                    treeSegment.transform.SetParent(this.transform, false);   //put the leaf and the branches under the tree parent, the movement is applied relative to the transform's local axes. 
                    treeSegment.GetComponent<LineRenderer>().SetPosition(0,initialPosision); 
                    treeSegment.GetComponent<LineRenderer>().SetPosition(1,transform.position);
                    treeSegment.GetComponent<LineRenderer>().startWidth = TrunkWidth;
                    treeSegment.GetComponent<LineRenderer>().endWidth = TrunkWidth;
                    break;
                case 'L':  
                    Vector3 IP = new Vector3(transform.position.x, transform.position.y-4, transform.position.z); // sposto di 2 in su le y.
                    // probabilmente meglio il meshRenderer che le linee per le foglie. per il branch potrei anche tener le linee
                    GameObject l = Instantiate(Leaf);
                    
                    l.transform.position = IP;
                    // makes the child keep its local orientation rather than
                    // its global orientation.

                    //FUNZIONA NEL TREESPAWN MA NON NEL PROJECT CON PERLIN NOISEE
                    //l.transform.SetParent(this.transform, false);   //put the leaf under the tree parent
                    break;
                    //X = basic structure of the tree
                case 'X':
                    break;
                    //clockwise on z axis
               case '+':
                    transform.Rotate(Vector3.back *  (angle  + UnityEngine.Random.Range(2f, 5f))); //add randomity to angles
                    break;
                    //reverse clockwise on z axis
                case '-':                                      
                    transform.Rotate(Vector3.forward * (angle  + UnityEngine.Random.Range(2f, 5f)));
                    break;
                    //moving clockwise on y axis
                case '*':
                    transform.Rotate(Vector3.up * (120  + UnityEngine.Random.Range(5f, 10f)));
                    break;
                    //moving reverse clockwise on y axis
                case '/':
                    transform.Rotate(Vector3.down* (120  + UnityEngine.Random.Range(5f, 10f))); 
                    break;
                    //save turtle position
                case '[':
                    //The bigger the tree(iteration limit) the bigger the width of the branches.
                    if(countForTrunk <= 0){TrunkWidth = 2f + iterationLimit/2;}//if the trunk is ended i recompute the width to the width of the branches
                    countForTrunk--;

                    transformStack.Push(new TransformInfo(){
                    position = transform.position,
                    rotation = transform.rotation
                });
                    break;
                    //turn back to saved position
                case ']':
                    TransformInfo ti = transformStack.Pop();
                    transform.position = ti.position;
                    transform.rotation = ti.rotation;
                    break;
                default:
                    throw new InvalidOperationException("invalid Tree operation");
            }
            i++;
        }

    }
}
