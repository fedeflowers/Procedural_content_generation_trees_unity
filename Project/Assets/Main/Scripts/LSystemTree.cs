using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using System.Text;
using UnityEditor;


public class TransformInfo
{
    public Vector3 position;
    public Quaternion rotation;
}
public class LSystemTree : MonoBehaviour
{
    public bool randomIgnoreRuleModifier = true;
    public float chanceToIgnoreRule = 0.3f;
    
    [SerializeField] private bool randomizeIterations = true;
    [SerializeField] private bool randomizeHeight = true;
    [Range(2, 4)][SerializeField] private int iterationLimit = 2;
    [SerializeField] private GameObject Branch;
    [SerializeField] private GameObject Leaf;
    private float lengthBranch = 10f; //keep it private so the user can randomize height by just clicking the bool randomizeHeight, without manually changing the height variable
    //[SerializeField] private float lengthLeaf = 10f;
    [SerializeField] private float angle = 20f;
    //private const float WidthBranches = 8f;
    private float TrunkWidth = 7f;  //I want to keep this private because the aim of the project it's creating multiple trees in random form,
                                    //so I don't want that an user changes the width of the trunk for making a single tree beatiful, I want it to be
                                    //always the one that I designed so it will look good with all types of iterations and so will be considered "ok" for all types of possible random trees
    private Stack<TransformInfo> transformStack;
    //private Dictionary<char, string> rules;
    private LSystemGenerator lsystem;
    public LSRule[] rules;
    [SerializeField] public string axiom = "X";
  

     private void Start()
    {
        transformStack = new Stack<TransformInfo>();
       
        if(randomizeIterations){
            iterationLimit =  UnityEngine.Random.Range(2, 5); // 2, 3, 4 are the possible iterations
        }
        if(randomizeHeight){
            lengthBranch = UnityEngine.Random.Range(6f, 11f); //from 6 to 10
        }
         // the only test we perform on the validity of the L-system is to have the axiom not null.
        if (axiom != string.Empty)
        {
            lsystem = new LSystemGenerator(rules, iterationLimit, randomIgnoreRuleModifier, chanceToIgnoreRule);
            // we generate the sentence given axiom and rule
            var sequence = lsystem.GenerateSentence(axiom);
            Debug.Log(sequence);
            // we parse the final sentence
            ParseAndBuild(sequence); //graphic result based on the sequence generated by the grammar
            //NOT IN USE
            //AdjustCircleOfNoTrees(iterationLimit);//last thing adjust the circonference where Trees can't spawn nearby
        }
        else
        {

#           if UNITY_EDITOR
            EditorUtility.DisplayDialog("Axiom is empty!", "", "Ok");
            if (EditorApplication.isPlaying)
                UnityEditor.EditorApplication.isPlaying = false;
            #endif
        }
    }
    private void ParseAndBuild(String sequence){
        int i = 0;
        //Basically a counter for the [, unitil the second [, I assume that the branches are trunk.
        //It's not the best since if I have a different structure of the tree it might produce not so beautiful results
        //it is also good to say that usualy u don't pop until the trunk has been created, so basically 99% of time the first [ it's always trunk
        //with the second one the problems might start for different structures of L-Systems.
        //Even if it's not the best for modularity I couldn't find a better solution, I tried to put a rule T-->TT and the axiom to become TX so 
        //I  had the trunk before the actually tree, but the problem is that removing the first F didn't just remove the first part of the trunk but it also
        //made the tree more compact and make it look really bad, so I decided to keep this not so modular implementation that works good with my grammars.
        int countForTrunk = 2; 
        //will be usefull at the end
        List<GameObject> TreeComponents = new List<GameObject>();
        foreach(char c in sequence){
            switch(c)
            {   
                //definition of variables for the L-systems, elements that the system can interpret
                case 'F':
                    Vector3 initialPosision = transform.position;
                    //Moves the transform in the direction and distance of translation;
                    //Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
                    transform.Translate(Vector3.up * lengthBranch); 

                    GameObject treeSegment = Instantiate(Branch, transform);
                    //Set the position of a vertex in the line.
                    treeSegment.GetComponent<LineRenderer>().SetPosition(0, initialPosision); 
                    treeSegment.GetComponent<LineRenderer>().SetPosition(1, transform.position);
                    //width of the line
                    treeSegment.GetComponent<LineRenderer>().startWidth = TrunkWidth;
                    treeSegment.GetComponent<LineRenderer>().endWidth = TrunkWidth;
                    //keeps the filesystem clean
                    TreeComponents.Add(treeSegment);
                    break;
                case 'L':  
                    Vector3 IP = new Vector3(transform.position.x, transform.position.y - 4, transform.position.z);
                    GameObject l = Instantiate(Leaf);
                    //set the position of the leaf
                    l.transform.position = IP;
                    //keeps the filesystem clean
                    TreeComponents.Add(l);
                    break;
                    //X = basic structure of the tree
                case 'X':
                    break;
                    //reverse clockwise on z axis, Vector3(0,0,-1)
               case '+':
                    transform.Rotate(Vector3.back *  (angle  + UnityEngine.Random.Range(2f, 5f))); //add randomity to angles
                    break;
                    //clockwise on z axis, Vector3(0,0,1) 
                case '-':                                      
                    transform.Rotate(Vector3.forward * (angle  + UnityEngine.Random.Range(2f, 5f)));
                    break;
                    //clockwise on y axis, Vector3(0,1,0)
                case '*':
                    transform.Rotate(Vector3.up * (120  + UnityEngine.Random.Range(5f, 10f)));
                    break;
                    //reverse clockwise on y axis, Vector3(0,-1,0)
                case '/':
                    transform.Rotate(Vector3.down* (120  + UnityEngine.Random.Range(5f, 10f))); 
                    break;
                    //save turtle position
                case '[':
                    //The bigger the tree(iteration limit) the bigger the width of the branches.
                     //this solution is hardcoded to keep it "cool" with all possible random trees that my script can generate.
                    if(countForTrunk <= 0){TrunkWidth = 2f + iterationLimit/2;}else{TrunkWidth = TrunkWidth + iterationLimit/2;}//if the trunk is ended i recompute the width to the width of the branches
                   
                    countForTrunk--;

                    transformStack.Push(new TransformInfo(){
                        position = transform.position,
                        rotation = transform.rotation
                        });
                    break;
                    //turn back to saved position
                case ']':
                    TransformInfo ti = transformStack.Pop();
                    transform.position = ti.position;
                    transform.rotation = ti.rotation;
                    break;
                default:
                    throw new InvalidOperationException("invalid Tree operation");
            }
            i++;
        }
        //Keep the unity management of objects nice and clean
        //REMINDER FOR MYSELF: if I add them to the parent at each iteration, then the leaves' position will be buggy so I need to add them later
        foreach(GameObject g in TreeComponents){
            g.transform.SetParent(transform);
        }
    }
}
